# 一次完整的HTTP的请求过程

## 简单过程

- 进行dns域名解析，获取其服务器的IP地址
- 根据这个IP地址，找到对应服务器，发起三次握手，
- 建立TCP请求，
- 从服务器获取资源
- 交给浏览器渲染
- 呈现给用户
- 关闭连接

## DNS域名解析

先从本地DNS缓存获取其域名->根域名服务器->根域名服务器找下一级，一层递归。

​	　**1）** **浏览器缓存**

　　当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）；

　　**2）** **系统缓存**

　　当浏览器缓存中无域名对应IP则会自动检查用户计算机系统Hosts文件DNS缓存是否有该域名对应IP；

　　**3）** **路由器缓存**

　　当浏览器及系统缓存中均无域名对应IP则进入路由器缓存中检查，以上三步均为客服端的DNS缓存；

　　**4）** **ISP****（互联网服务提供商）DNS****缓存**

　　当在用户客服端查找不到域名对应IP地址，则将进入ISP DNS缓存中进行查询。比如你用的是电信的网络，则会进入电信的DNS缓存服务器中进行查找；

　　**5）** **根域名服务器**

　　当以上均未完成，则进入根服务器进行查询。全球仅有13台根域名服务器，1个主根域名服务器，其余12为辅根域名服务器。根域名收到请求后会查看区域文件记录，若无则将其管辖范围内顶级域名（如.com）服务器IP告诉本地DNS服务器；

　　**6）** **顶级域名服务器**

　　顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的IP地址告诉本地DNS服务器；

　　**7）** **主域名服务器**

　　主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录；

　　**8**）**保存结果至缓存**

　　本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个IP地址与web服务器建立链接。

## 三次握手

本地发请求给服务器，服务器返回请求，本地在发送给服务器。

## 使用TCP连接

### TCP

端到端的可靠连接，需要两端同时在线，有重发，恢复，有序，确认信息

### UDP

是对不可靠，面向报文，不使用流量控制和拥塞控制

## 渲染

解析DOM树和CSS文件的渲染树，

一边解析一边渲染，

执行js会阻塞下载。

### 详细化

根据内核（Trident（也称IE内核）、webkit、Blink、Gecko）内核分渲染引擎和js引擎

​	Trident（也称IE内核）、webkit、Blink、Gecko

# [浏览器是怎么样渲染一个页面的](https://www.cnblogs.com/jesse-band/p/4625633.html)

# **解析与构建DOM树**

解析html文件构建DOM树的一些规则：

1，外部样式会阻塞后续脚本执行，直到外部样式加载并解析完毕。

2，外部样式不会阻塞后续外部脚本的加载，但会阻塞外部脚本的执行。

3，如果后续外部脚本含有async属性（IE下为defer），则外部样式不会阻塞该脚本的加载和运行。

4，对于动态创建的link标签不会阻塞其后动态创建的script的加载与执行，不管script标签是否具有async属性，但对于其他非动态创建的script，以上三条结论仍适用

# **构建呈现树**

HTML解析完毕后，开始构建呈现树RenderTree，这一步的主要工作在于将css样式应用到DOM节点上面，WebKit内核将这一过程称为附着，其他浏览器有不同的概念。对前端工程师而言这个过程会涉及到css层叠问题。

首先将根据样式重要性排序，由低到高依次为：

1，浏览器声明

2，用户普通声明

3，作者普通声明

4，作者重要声明

5，用户重要声明

对于同一重要级别，则是根据css选择符的特指度来判定优先级；

各级别的优先级：

important > 内联 > ID > 类 > 标签|伪类|属性选择器 > 伪对象 > 通配符 > 继承

1，权值的大小跟选择器的类型和数量有关

2，样式的优先级跟样式的定义顺序有关

呈现树的每一个节点即为与其对应的DOM节点的css框，框的类型与DOM节点的display属性有关，block元素生成block框，inline元素生成inline框，每一个呈现树节点都有与之对应的DOM节点，但DOM节点不一定有与之相对应的呈现树节点，你如display属性为none的DOM节点，而且呈现树节点在呈现树中的位置与他们在DOM树中的位置不一定相同，比如float与绝对定位元素。

# **布局** 

定位元素的坐标和大小，是否换行，各种 position, overflow， z-index 属性

# **绘制**

这里有两个概念，一个是 Reflow，另一个是 Repaint。

repaint 屏幕的一部分要重画，比如某个css的背景色变了，但是元素的几何尺寸没有变。

reflow 意味着元件的几何尺寸变了，我们需要重新验证并计算render tree。是render tree的一部分或全部发生了变化，这就是reflow 或是layout。reflow的成本比repaint的成本高很多，DOM tree里面的每个节点都会有reflow方法，一个节点的reflow很有可能导致子节点，甚至是父节点以及同级节点的reflow。

display:none 会触发 reflow，而 visibility:hidden 只会触发 repaint。

# 参考

[答寒冬九问之讲讲输入完网址按下回车，到看到网页这个过程中发生了什么。](http://www.cnblogs.com/dojo-lzz/p/3983335.html)

[CSS选择器、优先级与匹配原理](http://www.cnblogs.com/aaronjs/p/3156809.html)